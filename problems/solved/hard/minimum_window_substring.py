# Min window can be generated by sliding window along possible 
# substrings. To identify a possible string you must expand 
# window from 0,0 till you see all elements in your key. This 
# process could include extra values that may be used later 
# in the key, so those values must be stored. After you have 
# an initial window, slide window by moving left pointer until 
# another value within the key is found. If element of key that 
# was moved on from is already in the window, simply check window 
# length, if not move right pointer till value is seen, or end 
# of array is reached. Algorithm is O(N+M). O(M) for initial scan 
# and count of t, O(N) as two pointers each see each index at 
# least once and perform constant operations for O(N+N) operations. 
def minWindow(s, t):
    """
    given string s, return minimum length substring of s s' 
    such that all characters in t are in s'.
    """

    N = len(s)
    M = len(t)

    if M > N:
        return ""
    
    if N == 1:
        return s if s == t else ""

    counter = {}

    # counter
    for char in t:        
        if char not in counter:
            counter[char] = 1
        else:
            counter[char] += 1

    left, right = -1, -1
    seen = {}

    # get initial possible window, store extra key values within substring
    while M > 0 and right + 1 < N:
        right += 1
        if s[right] in counter:
            if counter[s[right]] > 0:
                if left < 0:
                    left = right
                counter[s[right]] -= 1
                M -= 1
            else:
                if s[right] in seen:
                    seen[s[right]] += 1
                else:
                    seen[s[right]] = 1
                

    # no valid window
    if M > 0:
        return ""

    minimum = float("inf")
    res = ""

    # slide window
    while left <= right and right < N:
        if right - left + 1 < minimum:
            minimum = right - left + 1
            res = s[left:right+1]
        
        curr = s[left]
        left += 1

        while left <= right and s[left] not in counter:
            left += 1

        if curr in seen and seen[curr] > 0:
            seen[curr] -= 1
        else:
            right += 1
            while right < N:
                if s[right] in counter:
                    if s[right] == curr:
                        break
                    if s[right] not in seen:
                        seen[s[right]] = 1
                    else:
                        seen[s[right]] += 1
                right += 1
        
    return res

print(minWindow("ADOBECODEBANC", "ABC"))
print(minWindow("ab", "a"))
print(minWindow("a", "b"))
print(minWindow("a", "aa"))
print(minWindow("ADOBECODEBANC", "ABCAB"))
print(minWindow("DOBECODEBANC", "CAB"))
print(minWindow("ADOBECODEBANC", "ABCB"))
print(minWindow("aabbccddabdabcbabadbacaabcabbacb", "abcabbacb"))